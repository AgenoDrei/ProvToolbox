<!DOCTYPE html>
<html>
  <head>
    <title>PROV-TEMPLATE: A Template System for PROV Documents</title>
    <meta charset='utf-8'>
    <script src='http://www.w3.org/Tools/respec/respec-w3c-common'
            async class='remove'></script>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js" class="remove"></script>
    <script src="prov-magic.js" class="remove"></script>

    <script class='remove'>
      var respecConfig = {
          specStatus: "unofficial",
          shortName:  "prov-template",
          editors: [
                {   name:       "Danius Michaelides",
                    url:        "http://www.ecs.soton.ac.uk/~dtm/",
                    company:    "University of Southampton",
                    companyURL: "http://www.ecs.soton.ac.uk/" },
                {   name:       "Trung Dong Huynh",
                    url:        "http://www.ecs.soton.ac.uk/~tdh/",
                    company:    "University of Southampton",
                    companyURL: "http://www.ecs.soton.ac.uk/" },
                {   name:       "Luc Moreau",
                    url:        "http://www.ecs.soton.ac.uk/~lavm/",
                    company:    "University of Southampton",
                    companyURL: "http://www.ecs.soton.ac.uk/" }
          ],
      localBiblio:  {
      "prov-json": {
      title:    "The PROV-JSON Serialization. A JSON Representation for the PROV Data Model"
      ,   href:     "http://www.w3.org/Submission/2013/SUBM-prov-json-20130424/"
      ,   authors:  [
      "Trung Dong Huynh",
      "Michael O. Jewell",
      "Amir Sezavar Keshavarz",
      "Danius T. Michaelides",
      "Huanjia Yang",
      "Luc Moreau"
      ]
      ,   status:   "Member-SUBM"
      ,   publisher:  "W3C"
      }
      }
          //previousMaturity: "FPWD",
          //previousPublishDate:  "1977-03-15",
          //wg:           "Cryptozoology Working Group",
          //wgURI:        "http://www.w3.org/2017/cryptozoology/",
          //wgPublicList: "public-animals",
          //wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/424242/status",
      };
    </script>


<script class="remove">
$(document).ready(function(){
// if glossary is in a string:
  //      $('#glossary_div').html(glossary_string)
        updateFigCaptions();
        updateCaptions();
        updateExamples();
        updateExamplesRefs();


	if (typeof String.prototype.startsWith != 'function') {
            String.prototype.startsWith = function (str) {
					    return this.indexOf(str) == 0;
					  };
        }
	if (typeof String.prototype.contains != 'function') {
            String.prototype.contains  = function (str) {
					    return this.indexOf(str) >= 0;
					  };
        }
      });
</script>
 
<style type="text/css">
.note { font-size:small; margin-left:50px }

.diamond {
    font-weight: normal;
    font-style: normal;
    font-size:100%;
    font-family: sans-serif;
}

table.thinborder {
	border-width: 1px;
	border-spacing: 0px;
	border-style: none;
	border-color: gray;
	border-collapse: collapse;
}

table.thinborder th {
	border-width: 1px;
	padding: 0px;
	border-style: solid;
	border-color: gray;
}

table.thinborder td {
	border-width: 1px;
	padding: 2px;
	border-style: solid;
	border-color: gray;
}

.anexample[data-count]::before {
    content: "Example " attr(data-count) ;
    font-family: sans-serif;
    font-size: 1.6ex;
    font-weight: bold;
}

/*
.anexample:before {
    content: "Example:";
    font-family: sans-serif;
    font-size: 1.6ex;
    font-weight: bold;
}

*/

.anexample {
    margin-top: 1ex;
    margin-bottom: 1ex;
    padding-left: 1ex;
    padding-right: 1ex;
    padding-top: 1ex;
    padding-bottom: 0.6ex;
    border: 1px dashed #2f6fab;
    background-color: #f9f9f9;
}
.anexample table {
    background-color: #f9f9f9;
}

.anexampleTitle {
    font-family: sans-serif;
    font-size: 1.6ex;
    font-weight: bold;
}

.anexampleTitle {
    font-family: sans-serif;
    font-size: 1.6ex;
    font-weight: bold;
}

</style>

  </head>
  <body>
    <section id='abstract'>
      <p>
        This document describes a templating system to generate PROV.
      </p>
    </section>

    <section id='sotd'>
      <p>
        This is probably the froodiest document that you will read all year. It has
        been authored using new means of achieving consensus that have been made 
        possible through nanoethanol implants.
      </p>
    </section>

<section id="introduction">
      <h2>Introduction</h2>

<p>
Generating provenance compatible with the PROV
data model [[prov-dm]] remains challenging. Indeed, all serializations of PROV, whether 
RDF [[prov-o]],  XML [[prov-xml]],  text [[prov-n]], or JSON
[[prov-json]] have got their own syntactic quirks, which makes them
difficult to generate directly. Likewise, specialized toolkits such as
ProvToolbox and ProvPy require non trivial programming expertise.
</p>

<p>Thus, recognizing that very often provenance follows patterns that are repeated during
the lifetime of an application, we propose a template system for PROV, with the following characteristics:
<ul>
<li> It follows a declarative approach, according to which a pattern
of provenance graph can be declared, specifying some variables acting as placeholder for values to be specified; the
pattern can be instantiated multiple times by providing bindings for
these variables.
<li> It allows a decoupling of the code that instruments the
application and the provenance generation component, the latter being
handled automatically by means of patterns.
<li> To avoid the proliferation of languages and serializations, patterns and bindings are themselves
expressed as PROV documents, allowing tools to be applied to them, to
analyse, check or validate them.
</ul>
</p>





<section id="namespaces">
      <h2>Namespaces</h2>

<p>The following namespaces and prefixes are used throughout this document.</p>



<table class="thinborder" style="margin-left: auto; margin-right: auto;">
<caption id="namespace-table"><span>Table 1</span> Prefix and namespaces used in this specification</caption>
<tbody>
<tr><td><b>Prefix</b></td>
    <td><b>Namespace IRI</b></td>
    <td><b>Definition</b></td></tr>
<tr><td><tt>tmpl</tt></td>
    <td><tt>http://openprovenance.org/tmpl#</tt></td>
    <td>The prov-template namespace</td></tr>
<tr><td><tt>var</tt></td>
    <td><tt>http://openprovenance.org/var#</tt></td>
    <td>The namespace for template variables</td></tr>
<tr><td><tt>vargen</tt></td>
    <td><tt>http://openprovenance.org/vargen#</tt></td>
    <td>The namespace for template gensym variables</td></tr>
<tr><td><tt>prov</tt></td><td><tt>http://www.w3.org/ns/prov#</tt></td><td>The PROV namespace</td></tr>
<tr><td><tt>xsd</tt></td><td><tt>http://www.w3.org/TR/xmlschema11-2/#</tt></td><td>The XSD namespace</td></tr>
</tbody>
</table>

<p>All other namespace prefixes are used in examples only. In
particular, IRIs starting with <tt>http://example.org</tt> represent
some application-dependent IRI [<cite><a class="bibref"
href="#bib-RFC3987">RFC3987</a></cite>].
</section>



<section id="conventions">
      <h2>Conventions</h2>


<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [[RFC2119]].</p>

<p>Examples throughout this document use the PROV-N Provenance Notation [[PROV-N]].</p>


<p>In this specification, we use the
term <a href="http://www.w3.org/TR/prov-dm/#term-qualified-name">Qualified
Name</a> in accordance to [[prov-dm]], and use its syntax as specified in [[prov-n]]
(see
production <a href="http://www.w3.org/TR/prov-n/#prod-QUALIFIED_NAME">prod-QUALIFIED_NAME</a>).
In compliance with [[prov-dm]], we note that a qualified name can be
mapped to an IRI by concatenating the IRI associated with the prefix
and the local part. </p>

</section>
</section>

<section id="template-definition">
 <h2>Template Definition</h2>

<p>A <dfn>PROV-template</dfn> is a PROV document that:
<ul>
<li> MUST contain a single bundle;
<li> MAY contain variables in the form of qualified names <tt>var:<em>x</em></tt> and <tt>vargen:<em>x</em></tt> in any position where such qualified names are allowed in PROV;
<li> MAY contain attributes in the prov-template namespace (prefix <tt>tmpl</tt>).
</ul>


<p>Table 1 summarizes the syntax and meaning of variables and attributes accepted in a PROV template. Their roles will be discussed in detail in the expansion algorithm.</p>

<table class="thinborder" style="margin-left: auto; margin-right: auto;">
<caption id="variable-table"><span>Table 1</span> Kinds of parameters and variables supported by the templating system</caption>
<tbody>
<tr><td><b>template variable</b></td><td><b>definition</b></td></tr>
<tr><td><tt>var:<em>x</em></tt></td><td>A variable <em>x</em> to be
replaced by its value according to the expansion algorithm. If no
binding is found, the following rules are applied.  If the variable occurs in attribute position, the
attribute is dropped. If in optional position of a statement (see
[[prov-n]], <a href="http://www.w3.org/TR/prov-n/#prov-n-optionals">section
2.4</a>), the variable is dropped. If in mandatory position of a
statement, it is an error situation (see error
<a href="#UnboundMandatoryVariable">UnboundMandatoryVariable</a>). </td></tr>
<tr><td><tt>vargen:<em>x</em></tt></td><td>A variable <em>x</em> to be
replaced by its value according to the expansion algorithm. If no
binding is found, the following rules are applied. If the variable occurs in attribute position, a unique qualified name (uuid)  is 
generated. If in optional position of a statement (see
[[prov-n]], <a href="http://www.w3.org/TR/prov-n/#prov-n-optionals">section
2.4</a>), the variable is dropped. If in mandatory position of a
statement, a unique qualified name (uuid)  is 
generated.</td></tr>
<tr><td><b>template parameter</b></td><td><b>definition</b></td></tr>
<tr><td><tt>tmpl:linked</tt></td><td>An attribute associated with a value that MUST be a qualified name also acting as a template variable <tt>v2</tt> (with either <tt>var</tt> or <tt>vargen</tt> namespace prefix). Its presence in a term with identifier <tt>v1</tt>  indicates that the variable <tt>v2</tt>  changes value synchronously with the value of <tt>v1</tt>.</td></tr>
<tr><td><tt>tmpl:label</tt></td><td>An attribute associated with a value that MUST be a qualified name  <tt>var:v</tt> also acting as a template variable. If bound, variable <tt>var:v</tt> MUST be bound to <a href="http://www.w3.org/TR/xmlschema11-2/#string"><span class="name">xsd:string</span></a> values. The expanded current term will contain  a <tt>prov:label</tt> for each value.</td></tr>
<tr><td><tt>tmpl:time</tt></td><td>An attribute associated with a value that MUST be a qualified name  <tt>var:<em>v</em></tt> also acting as a template variable. This attribute may only occur in a Generation, Usage, Invalidation, Start, or End term. If <tt>var:<em>v</em></tt> is bound, variable <tt>var:<em>v</em></tt> MUST be bound to <a href="http://www.w3.org/TR/xmlschema11-2/#dateTime"><span class="name">xsd:dateTime</span></a> values. The expanded current term will be provided the corresponding time information.</td></tr>
<tr><td><tt>tmpl:startTime</tt></td><td>An attribute associated with a value that MUST be a qualified name  <tt>var:<em>v</em></tt> also acting as a template variable. This attribute may only occur in an Activity term. If <tt>var:<em>v</em></tt> is bound, variable <tt>var:<em>v</em></tt> MUST be bound to <a href="http://www.w3.org/TR/xmlschema11-2/#dateTime"><span class="name">xsd:dateTime</span></a> values. The expanded current activity will be provided the corresponding start time information.</td></tr>
<tr><td><tt>tmpl:endTime</tt></td><td>An attribute associated with a value that MUST be a qualified name  <tt>var:<em>v</em></tt> also acting as a template variable. This attribute may only occur in an Activity term. If <tt>var:<em>v</em></tt> is bound, variable <tt>var:<em>v</em></tt> MUST be bound to <a href="http://www.w3.org/TR/xmlschema11-2/#dateTime"><span class="name">xsd:dateTime</span></a> values. The expanded current activity will be provided the corresponding end time information.</td></tr>
</tbody>
</table>

<div class="anexample" id="example-1">
<p>The following template contains two variables <tt>var:a</tt> and <tt>var:b</tt>.</p>
<div class="example">
<pre class="highlight">
document
 prefix ex &lt;http://example.org&gt;
 prefix var &lt;http://openprovenance.org/var#&gt;

 bundle ex:b 
  agent(var:a)
  entity(var:b)
  wasAttributedTo(var:b, var:a)
 endBundle
endDocument
<pre>
</div>
With the following values, <tt>ex:ag</tt> and <tt>ex:en</tt>, for <tt>var:a</tt> and <tt>var:b</tt>, respectively, the template expands to the following document:
<div class="example">
<pre class="highlight">
document
 prefix ex &lt;http://example.org&gt;
 prefix tmpl &lt;http://openprovenance.org/tmpl#&gt;
 prefix xsd &lt;http://www.w3.org/2001/XMLSchema&gt;
 bundle ex:b 
  agent(ex:ag,[tmpl:order = "[0]" %% xsd:string])
  entity(ex:en,[tmpl:order = "[0]" %% xsd:string])
  wasAttributedTo(ex:en, ex:ag,[tmpl:order = "[0, 0]" %% xsd:string])
 endBundle
endDocument
<pre>
</div>
</div>

<div class="anexample"  id="example-2">
<p>Multiple values are allowed for each variable, for instance <tt>ex:ag1</tt>, <tt>ex:ag2</tt> for  <tt>var:a</tt>, and <tt>ex:en1</tt>, <tt>ex:en2</tt>, <tt>ex:en3</tt>, for <tt>var:b</tt>. By default, the cartesian product of the values set forms the set of all possibilities to instantiate each statement in the template. We obtain:</p>
<div class="example">
<pre class="highlight">
document
 prefix ex &lt;http://example.org&gt;
 prefix tmpl &lt;http://openprovenance.org/tmpl#&gt;
 prefix xsd &lt;http://www.w3.org/2001/XMLSchema&gt;
 bundle ex:b 
  agent(ex:ag1,[tmpl:order = "[0]" %% xsd:string])
  agent(ex:ag2,[tmpl:order = "[1]" %% xsd:string])
  entity(ex:en1,[tmpl:order = "[0]" %% xsd:string])
  entity(ex:en2,[tmpl:order = "[1]" %% xsd:string])
  entity(ex:en3,[tmpl:order = "[2]" %% xsd:string])
  wasAttributedTo(ex:en1, ex:ag1,[tmpl:order = "[0, 0]" %% xsd:string])
  wasAttributedTo(ex:en1, ex:ag2,[tmpl:order = "[1, 0]" %% xsd:string])
  wasAttributedTo(ex:en2, ex:ag1,[tmpl:order = "[0, 1]" %% xsd:string])
  wasAttributedTo(ex:en2, ex:ag2,[tmpl:order = "[1, 1]" %% xsd:string])
  wasAttributedTo(ex:en3, ex:ag1,[tmpl:order = "[0, 2]" %% xsd:string])
  wasAttributedTo(ex:en3, ex:ag2,[tmpl:order = "[1, 2]" %% xsd:string])
  endBundle
endDocument
<pre>
</div>
In the expanded document, the attribute <tt>tmpl:order</tt> indicates which combination of variable values is used to instantiate the current statement.  In the <tt>wasAttributedTo</tt> statement, it indicates that two independent groups of variables are considered.  There are two possible values (denoted by index 0 and 1) for the first group (i.e., variable <tt>var:b</tt>) and three possible values (denoted by index 0, 1, and 2) for the second group (i.e., variable <tt>var:a</tt>).
</div>


<div class="anexample"  id="example-3">
<p>In some cases, the cartesian product of possibilities is not desirable. Instance, one wants the values are allowed for each variable, for instance <tt>ex:ag1</tt>, <tt>ex:ag2</tt> for  <tt>var:a</tt>, and <tt>ex:en1</tt>, <tt>ex:en2</tt> for <tt>var:b</tt>. By default, the cartesian product of the values set forms the set of all possibilities to instantiate each statement in the template. Hence, we modify the template of <a href="#example-1" class="anexample-ref"><span>Example REF</span></a> by adding the <tt>tmpl:linked</tt> attribute in the template.</p>
<div class="example">
<pre class="highlight">
document
 prefix ex &lt;http://example.org&gt;
 prefix var &lt;http://openprovenance.org/var#&gt;

 bundle ex:b 
  agent(var:a)
  entity(var:b)
  wasAttributedTo(var:b, var:a)
 endBundle
endDocument
<pre>
</div>
The expansion now looks like the following. We see that the value <tt>ex:en1</tt> is used  at the same time as <tt>ex:ag1</tt>.
<div class="example">
<pre class="highlight">
document
 prefix ex &lt;http://example.org&gt;
 prefix tmpl &lt;http://openprovenance.org/tmpl#&gt;
 prefix xsd &lt;http://www.w3.org/2001/XMLSchema&gt;
 bundle ex:b 
  agent(ex:ag1,[tmpl:order = "[0]" %% xsd:string])
  agent(ex:ag2,[tmpl:order = "[1]" %% xsd:string])
  entity(ex:en1,[tmpl:order = "[0]" %% xsd:string])
  entity(ex:en2,[tmpl:order = "[1]" %% xsd:string])
  wasAttributedTo(ex:en1, ex:ag1,[tmpl:order = "[0]" %% xsd:string])
  wasAttributedTo(ex:en2, ex:ag2,[tmpl:order = "[1]" %% xsd:string])
 endBundle
endDocument
<pre>
</div>
In the expanded document, the attribute <tt>tmpl:order</tt> indicates that a single group of variables is used for the <tt>wasAttributedTo</tt> statement:  it has two possible values (denoted by index 0 and 1).
</div>


</section>

<section id="algorithm">
      <h2>Algorithm</h2>


<section id="grouping">
      <h2>Variable Grouping</h2>

<p>We define a <em>variable group</em>, or <dfn>group</dfn> for short, a set of variables that are expected to change values in lockstep with each other. Groups are identified by a natural number. A <dfn>pattern's grouping of variables</dfn> is a partitioning of the set of variables occurring in a pattern; each partition forms a group and is allocated a natural number.  </p>

<p>A <dfn>binding</dfn> is an association between a variable and some values. If there is a binding for a variable, it is said to be <dfn>bound</dfn>.</p>

<p>All variables belonging to a given group MUST be bound to the same number of values, since their values have to change in lockstep manner. If this condition is not satisfied, it is an error situation (see error
<a href="#IncorrectNumberOfBindingsForGroupVariable">IncorrectNumberOfBindingsForGroupVariable</a>).</p>

<p>A variable SHALL NOT belong to more than one group.</p>

<p>The algorithm to deterministically create a  grouping of variables for a pattern P is as follows.</p>
<pre class="highlight">
Grouping function (Pattern: P) {
  List&lt;Variable&gt; variable_list=sort(extract_variables(P));

  Hashtable &lt;Variable,Set&lt;Variable&gt;&gt; linked = extract_linked_variables(P); // includes transitive closure
  
  Grouping g=new Grouping();
  int count=0;
  for (Variable v: variable_list) {
    if (!(belong v g)) {
       add v and linked.get(v) to g as group identified by count;
    }
    count++;
  }	
  return g;
}
</pre>

<p>First, all variables are extracted from the pattern and sorted (based on an alphabetical sort of their uris).  Then, all linked variables are computed, in the form of a hashmap, associating a variable to the variables it is linked with. It is assumed that the transitive closure of this relation is computed here.  Then, each variable (if not already inserted in the grouping) is added to the grouping with the variables it is linked with. Groups are deterministically identified, starting with value 0.</p>

<p>In the absence of <tt>tmpl:linked</tt> attribute, we have as many groups as variables. </p>

<div class="anexample"  id="example-4">

<p>In <a href="#example-1" class="anexample-ref"><span>Example REF</span></a> and <a href="#example-2" class="anexample-ref"><span>Example REF</span></a>,  the grouping is as follows:</p>

<table class="thinborder" >
<tbody>
<tr><td><b>groups</b></td><td><b>variables</b></td></tr>
<tr><td>0</td><td><tt>var:a</tt></td></tr>
<tr><td>1</td><td><tt>var:b</tt></td></tr>
</tbody>
</table>


<p>In <a href="#example-3" class="anexample-ref"><span>Example REF</span></a>,  the grouping consists of a single group:</p>

<table class="thinborder">
<tbody>
<tr><td><b>groups</b></td><td><b>variables</b></td></tr>
<tr><td>0</td><td><tt>var:a</tt>, <tt>var:b</tt></td></tr>
</tbody>
</table>
</div>
</section>

<section id="using">
      <h2>Group Using</h2>
</section>


<section id="binding">
      <h2>Binding Structure</h2>
</section>

<section id="indexing">
      <h2>Variable Value Indexing</h2>
</section>


<section id="expansion">
      <h2>Expansion</h2>
</section>


Basic algorithm:
<ol>
<li> create a mapping of 'group' to list of variables
<ul>
<li> for each variable, put it into a group:
      if specified use that group
      else create a new group (name used needs to be deterministic)
</ul>
</li>

<li> for each statement:
<ol>
<li> from the variables in that statement determine which groups it involves</li>
<li> use the list of involved groups and number of bindings in each to
    generate a multi-dimensional index</li>
<li> for each point in the index, write out the statement using the
   appropiate
    values in the variable bindings; tmpl:order is the point index</li>
</ol>
</li>
</ol>

</section>

<section id="examples">
      <h2>Examples</h2>

<pre class="example">
Template:
  entity(var:a)
  entity(var:b)
  wasAttributedTo(var:b, var:a)
Bindings:
  var:a = [uri1, uri2, uri3]
  var:b = [uriA, uriB]

groups = { 1: [var:a], 2: [var:b] }

statement 1:
  variables: var:a
  uses: group 1 (length 3)
  index: [(1),(2),(3)]
  write:
    entity(uri1, [tmpl:order="1"])
    entity(uri2, [tmpl:order="2"])
    entity(uri3, [tmpl:order="3"])

statement 2:
  variables: var:b
  uses: group 2 (length 2)
  index: [(1),(2)]
  write:
    entity(uriA, [tmpl:order="1"])
    entity(uriB, [tmpl:order="2"])

statement 3:
  variables: var:b, var:a
  uses: group 2 (length 2), group 1 (length 3)
  index: [(1,1),(1,2)(1,3),(2,1),(2,2),(2,3)]
  write:
    wasAttributedTo(uriA, uri1, [tmpl:order="1,1"])
    wasAttributedTo(uriA, uri2, [tmpl:order="1,2"])
    wasAttributedTo(uriA, uri3, [tmpl:order="1,3"])
    wasAttributedTo(uriB, uri1, [tmpl:order="2,1"])
    wasAttributedTo(uriB, uri2, [tmpl:order="2,2"])
    wasAttributedTo(uriB, uri3, [tmpl:order="2,3"])
</pre>

<pre class="example">
Template:
  entity(var:a, [app:group='1'])
  entity(var:b, [app:group='1'])
  wasAttributedTo(var:b, var:a)
Bindings:
  var:a = [uri1, uri2]
  var:b = [uriA, uriB]
groups = { 1: [var:a, var:b] }
statement 1:
  variables: var:a
  uses: group 1 (length 2)
  index: [(1),(2)]
  write:
    entity(uri1, [tmpl:order="1"])
    entity(uri2, [tmpl:order="2"])

statement 2:
  variables: var:b
  uses: group 2 (length 2)
  index: [(1),(2)]
  write:
    entity(uriA, [tmpl:order="1"])
    entity(uriB, [tmpl:order="2"])

statement 3:
  variables: var:b, var:a
  uses: group 1 (length 2)
  index: [(1),(2)]
  write:
    wasAttributedTo(uriA, uri1, [tmpl:order="1"])
    wasAttributedTo(uriB, uri2, [tmpl:order="2"])
</pre>

<pre class="example">
Template:
  entity(var:x)
  agent(var:ag)
  wasAttributedTo(var:x, var:ag, [ my:attr='var:a' ])
Bindings:
  var:x = [uri1, uri2, uri2]
  var:ag = [uriA, uriB]
  var:a = [[attr1], [attr2], [attr3], [attr4], [attr5], [attr6a, attr6b]]

Expands to:

  entity(uri1, [tmpl:order="1"])
  entity(uri2, [tmpl:order="2"])
  entity(uri3, [tmpl:order="3"])

  entity(uriA, [tmpl:order="1"])
  entity(uriB, [tmpl:order="2"])

  wasAttributedTo(uri1, uriA, [my:attr='attr1', tmpl:order="1,1"])
  wasAttributedTo(uri1, uriB, [my:attr='attr2', tmpl:order="1,2"])
  wasAttributedTo(uri2, uriA, [my:attr='attr3', tmpl:order="2,1"])
  wasAttributedTo(uri2, uriB, [my:attr='attr4', tmpl:order="2,2"])
  wasAttributedTo(uri3, uriA, [my:attr='attr5', tmpl:order="3,1"])
  wasAttributedTo(uri3, uriB, [my:attr='attr6a', my:attr='attr6b', tmpl:order="3,2"])
</pre>
</section>


<section id="environment">
      <h2>Environment</h2>

<div class="example">
<pre>
document
prefix app <http://a/>
prefix var <http://v/>
prefix ex <http://ex/>

entity(var:a,[app:value0='ex:foo',app:value1='ex:bar'])

entity(var:b,[prov:value='ex:foo', tmpl:order=0])
entity(var:b,[prov:value='ex:bar', tmpl:order=1])

endDocument
</pre>
</div>
</section>



<section id="variables">
      <h2>Variables</h2>


<table class="thinborder" style="margin-left: auto; margin-right: auto;">
<caption id="variable-table"><span>Table xx</span> Kinds of parameters and variables supported by the templating system</caption>
<tbody>
<tr><td><b>expanded instance parameter</b></td><td><b>definition</b></td></tr>
<tr><td><tt>tmpl:order</tt></td><td>an attribute added to a statement by the expansion process to specify the index used to compute the actual binding that defined the current instantiation.</td></tr>
<tr><td><b>binding parameter</b></td><td><b>definition</b></td></tr>
<tr><td><tt>tmpl:value_0</tt></td><td> an attribute ...</td></tr>
<tr><td><tt>tmpl:value_1</tt></td><td> an attribute ...</td></tr>
<tr><td><tt>tmpl:value_</tt><em>n</em></td><td> an attribute ...</td></tr>
<tr><td><tt>tmpl:2dvalue_0_0</tt></td><td> an attribute ...</td></tr>
<tr><td><tt>tmpl:2dvalue_<em>x</em>_<em>y</em></tt></td><td> an attribute ...</td></tr>
</tbody>
</table>

</section>


<section id="errors">
<h2>Errors</h2>
<p id="UnboundMandatoryVariable">UnboundMandatoryVariable</p>

<p id="IncorrectNumberOfBindingsForGroupVariable">IncorrectNumberOfBindingsForGroupVariable</p>
</section>

<section id="implementation" class="informative">
      <h2>Implementation</h2>


<p>ProvToolbox provconvert command line ... </p>

</section>



</body>
</html>
