<!DOCTYPE html>
<html>
  <head>
    <title>PROV-TEMPLATE: A Template System for PROV Documents</title>
    <meta charset='utf-8'>
    <script src='http://www.w3.org/Tools/respec/respec-w3c-common'
            async class='remove'></script>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js" class="remove"></script>
    <script src="prov-magic.js" class="remove"></script>

    <script class='remove'>
      var respecConfig = {
          specStatus: "unofficial",
          shortName:  "prov-template",
          editors: [
                {   name:       "Danius Michaelides",
                    url:        "http://www.ecs.soton.ac.uk/~dtm/",
                    company:    "University of Southampton",
                    companyURL: "http://www.ecs.soton.ac.uk/" },
                {   name:       "Trung Dong Huynh",
                    url:        "http://www.ecs.soton.ac.uk/~tdh/",
                    company:    "University of Southampton",
                    companyURL: "http://www.ecs.soton.ac.uk/" },
                {   name:       "Luc Moreau",
                    url:        "http://www.ecs.soton.ac.uk/~lavm/",
                    company:    "University of Southampton",
                    companyURL: "http://www.ecs.soton.ac.uk/" }
          ],
      localBiblio:  {
      "prov-json": {
      title:    "The PROV-JSON Serialization. A JSON Representation for the PROV Data Model"
      ,   href:     "http://www.w3.org/Submission/2013/SUBM-prov-json-20130424/"
      ,   authors:  [
      "Trung Dong Huynh",
      "Michael O. Jewell",
      "Amir Sezavar Keshavarz",
      "Danius T. Michaelides",
      "Huanjia Yang",
      "Luc Moreau"
      ]
      ,   status:   "Member-SUBM"
      ,   publisher:  "W3C"
      }
      }
          //previousMaturity: "FPWD",
          //previousPublishDate:  "1977-03-15",
          //wg:           "Cryptozoology Working Group",
          //wgURI:        "http://www.w3.org/2017/cryptozoology/",
          //wgPublicList: "public-animals",
          //wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/424242/status",
      };
    </script>


<script class="remove">
$(document).ready(function(){
// if glossary is in a string:
  //      $('#glossary_div').html(glossary_string)
        updateFigCaptions();
        updateCaptions();
        updateExamples();
        updateExamplesRefs();


	if (typeof String.prototype.startsWith != 'function') {
            String.prototype.startsWith = function (str) {
					    return this.indexOf(str) == 0;
					  };
        }
	if (typeof String.prototype.contains != 'function') {
            String.prototype.contains  = function (str) {
					    return this.indexOf(str) >= 0;
					  };
        }
      });
</script>
 
<style type="text/css">
.note { font-size:small; margin-left:50px }

.diamond {
    font-weight: normal;
    font-style: normal;
    font-size:100%;
    font-family: sans-serif;
}

table.thinborder {
	border-width: 1px;
	border-spacing: 0px;
	border-style: none;
	border-color: gray;
	border-collapse: collapse;
}

table.thinborder th {
	border-width: 1px;
	padding: 0px;
	border-style: solid;
	border-color: gray;
}

table.thinborder td {
	border-width: 1px;
	padding: 2px;
	border-style: solid;
	border-color: gray;
}

.anexample[data-count]::before {
    content: "Example " attr(data-count) ;
    font-family: sans-serif;
    font-size: 1.6ex;
    font-weight: bold;
}

/*
.anexample:before {
    content: "Example:";
    font-family: sans-serif;
    font-size: 1.6ex;
    font-weight: bold;
}

*/

.anexample {
    margin-top: 1ex;
    margin-bottom: 1ex;
    padding-left: 1ex;
    padding-right: 1ex;
    padding-top: 1ex;
    padding-bottom: 0.6ex;
    border: 1px dashed #2f6fab;
    background-color: #f9f9f9;
}
.anexample table {
    background-color: #f9f9f9;
}

.anexampleTitle {
    font-family: sans-serif;
    font-size: 1.6ex;
    font-weight: bold;
}

.anexampleTitle {
    font-family: sans-serif;
    font-size: 1.6ex;
    font-weight: bold;
}

</style>

  </head>
  <body>
    <section id='abstract'>
      <p>
        This document describes a templating system to generate PROV.
      </p>
    </section>

    <section id='sotd'>
      <p>
        This is probably the froodiest document that you will read all year. It has
        been authored using new means of achieving consensus that have been made 
        possible through nanoethanol implants.
      </p>
    </section>

<section id="introduction">
      <h2>Introduction</h2>

<p>
Generating provenance compatible with the PROV
data model [[prov-dm]] remains challenging. Indeed, all serializations of PROV, whether 
RDF [[prov-o]],  XML [[prov-xml]],  text [[prov-n]], or JSON
[[prov-json]] have got their own syntactic quirks, which makes them
difficult to generate directly. Likewise, specialized toolkits such as
ProvToolbox and ProvPy require non trivial programming expertise.
</p>

<p>Thus, recognizing that very often provenance follows patterns that are repeated during
the lifetime of an application, we propose a template system for PROV, with the following characteristics:
<ul>
<li> It follows a declarative approach, according to which a pattern
of provenance graph can be declared, specifying some variables acting as placeholder for values to be specified; the
pattern can be instantiated multiple times by providing bindings for
these variables.
<li> It allows a decoupling of the code that instruments the
application and the provenance generation component, the latter being
handled automatically by means of patterns.
<li> To avoid the proliferation of languages and serializations, patterns and bindings are themselves
expressed as PROV documents, allowing tools to be applied to them, to
analyse, check or validate them.
</ul>
</p>





<section id="namespaces">
      <h2>Namespaces</h2>

<p>The following namespaces and prefixes are used throughout this document.</p>



<table class="thinborder" style="margin-left: auto; margin-right: auto;">
<caption id="namespace-table"><span>Table 1</span> Prefix and namespaces used in this specification</caption>
<tbody>
<tr><td><b>Prefix</b></td>
    <td><b>Namespace IRI</b></td>
    <td><b>Definition</b></td></tr>
<tr><td><tt>tmpl</tt></td>
    <td><tt>http://openprovenance.org/tmpl#</tt></td>
    <td>The prov-template namespace</td></tr>
<tr><td><tt>var</tt></td>
    <td><tt>http://openprovenance.org/var#</tt></td>
    <td>The namespace for template variables</td></tr>
<tr><td><tt>vargen</tt></td>
    <td><tt>http://openprovenance.org/vargen#</tt></td>
    <td>The namespace for template gensym variables</td></tr>
<tr><td><tt>prov</tt></td><td><tt>http://www.w3.org/ns/prov#</tt></td><td>The PROV namespace</td></tr>
<tr><td><tt>xsd</tt></td><td><tt>http://www.w3.org/TR/xmlschema11-2/#</tt></td><td>The XSD namespace</td></tr>
</tbody>
</table>

<p>All other namespace prefixes are used in examples only. In
particular, IRIs starting with <tt>http://example.org</tt> represent
some application-dependent IRI [<cite><a class="bibref"
href="#bib-RFC3987">RFC3987</a></cite>].
</section>



<section id="conventions">
      <h2>Conventions</h2>


<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [[RFC2119]].</p>

<p>Examples throughout this document use the PROV-N Provenance Notation [[prov-n]].</p>


<p>In this specification, we use the
term <a href="http://www.w3.org/TR/prov-dm/#term-qualified-name">Qualified
Name</a> in accordance to [[prov-dm]], and use its syntax as specified in [[prov-n]]
(see
production <a href="http://www.w3.org/TR/prov-n/#prod-QUALIFIED_NAME">prod-QUALIFIED_NAME</a>).
In compliance with [[prov-dm]], we note that a qualified name can be
mapped to an IRI by concatenating the IRI associated with the prefix
and the local part. </p>

</section>
</section>

<section id="template-definition">
 <h2>Template Definition</h2>

<p>A <dfn>PROV-template</dfn> is a PROV document that:
<ul>
<li> MUST contain a single bundle;
<li> MAY contain variables in the form of qualified names <tt>var:<em>x</em></tt> and <tt>vargen:<em>x</em></tt> in any position where such qualified names are allowed in PROV;
<li> MAY contain attributes in the prov-template namespace (prefix <tt>tmpl</tt>).
</ul>


<p>Table 1 summarizes the syntax and meaning of variables and attributes accepted in a PROV template. Their roles will be discussed in detail in the expansion algorithm.</p>

<table class="thinborder" style="margin-left: auto; margin-right: auto;">
<caption id="variable-table"><span>Table 1</span> Kinds of parameters and variables supported by the templating system</caption>
<tbody>
<tr><td><b>template variable</b></td><td><b>definition</b></td></tr>
<tr><td><tt>var:<em>x</em></tt></td><td>A variable <em>x</em> to be
replaced by its value according to the expansion algorithm. If no
binding is found, the following rules are applied.  If the variable occurs in attribute position, the
attribute is dropped. If in optional position of a statement (see
[[prov-n]], <a href="http://www.w3.org/TR/prov-n/#prov-n-optionals">section
2.4</a>), the variable is dropped. If in mandatory position of a
statement, it is an error situation (see error
<a href="#UnboundMandatoryVariable">UnboundMandatoryVariable</a>). </td></tr>
<tr><td><tt>vargen:<em>x</em></tt></td><td>A variable <em>x</em> to be
replaced by its value according to the expansion algorithm. If no
binding is found, the following rules are applied. If the variable occurs in attribute position, a unique qualified name (uuid)  is 
generated. If in optional position of a statement (see
[[prov-n]], <a href="http://www.w3.org/TR/prov-n/#prov-n-optionals">section
2.4</a>), the variable is dropped. If in mandatory position of a
statement, a unique qualified name (uuid)  is 
generated.</td></tr>
<tr><td><b>template parameter</b></td><td><b>definition</b></td></tr>
<tr><td><tt>tmpl:linked</tt></td><td>An attribute associated with a value that MUST be a qualified name also acting as a template variable <tt>v2</tt> (with either <tt>var</tt> or <tt>vargen</tt> namespace prefix). Its presence in a term with identifier <tt>v1</tt>  indicates that the variable <tt>v2</tt>  changes value synchronously with the value of <tt>v1</tt>.</td></tr>
<tr><td><tt>tmpl:label</tt></td><td>An attribute associated with a value that MUST be a qualified name  <tt>var:v</tt> also acting as a template variable. If bound, variable <tt>var:v</tt> MUST be bound to <a href="http://www.w3.org/TR/xmlschema11-2/#string"><span class="name">xsd:string</span></a> values. The expanded current term will contain  a <tt>prov:label</tt> for each value.</td></tr>
<tr><td><tt>tmpl:time</tt></td><td>An attribute associated with a value that MUST be a qualified name  <tt>var:<em>v</em></tt> also acting as a template variable. This attribute may only occur in a Generation, Usage, Invalidation, Start, or End term. If <tt>var:<em>v</em></tt> is bound, variable <tt>var:<em>v</em></tt> MUST be bound to <a href="http://www.w3.org/TR/xmlschema11-2/#dateTime"><span class="name">xsd:dateTime</span></a> values. The expanded current term will be provided the corresponding time information.</td></tr>
<tr><td><tt>tmpl:startTime</tt></td><td>An attribute associated with a value that MUST be a qualified name  <tt>var:<em>v</em></tt> also acting as a template variable. This attribute may only occur in an Activity term. If <tt>var:<em>v</em></tt> is bound, variable <tt>var:<em>v</em></tt> MUST be bound to <a href="http://www.w3.org/TR/xmlschema11-2/#dateTime"><span class="name">xsd:dateTime</span></a> values. The expanded current activity will be provided the corresponding start time information.</td></tr>
<tr><td><tt>tmpl:endTime</tt></td><td>An attribute associated with a value that MUST be a qualified name  <tt>var:<em>v</em></tt> also acting as a template variable. This attribute may only occur in an Activity term. If <tt>var:<em>v</em></tt> is bound, variable <tt>var:<em>v</em></tt> MUST be bound to <a href="http://www.w3.org/TR/xmlschema11-2/#dateTime"><span class="name">xsd:dateTime</span></a> values. The expanded current activity will be provided the corresponding end time information.</td></tr>
</tbody>
</table>

<div class="anexample" id="example-1">
<p>The following template contains two variables <tt>var:a</tt> and <tt>var:b</tt>.</p>
<div class="example">
<pre class="highlight">
document
 prefix ex &lt;http://example.org&gt;
 prefix var &lt;http://openprovenance.org/var#&gt;

 bundle ex:b 
  agent(var:a)
  entity(var:b)
  wasAttributedTo(var:b, var:a)
 endBundle
endDocument
<pre>
</div>
With the following values, <tt>ex:ag</tt> and <tt>ex:en</tt>, for <tt>var:a</tt> and <tt>var:b</tt>, respectively, the template expands to the following document:
<div class="example">
<pre class="highlight">
document
 prefix ex &lt;http://example.org&gt;
 prefix tmpl &lt;http://openprovenance.org/tmpl#&gt;
 prefix xsd &lt;http://www.w3.org/2001/XMLSchema&gt;
 bundle ex:b 
  agent(ex:ag,[tmpl:order = "[0]" %% xsd:string])
  entity(ex:en,[tmpl:order = "[0]" %% xsd:string])
  wasAttributedTo(ex:en, ex:ag,[tmpl:order = "[0, 0]" %% xsd:string])
 endBundle
endDocument
<pre>
</div>
</div>

<div class="anexample"  id="example-2">
<p>Multiple values are allowed for each variable, for instance <tt>ex:ag1</tt>, <tt>ex:ag2</tt> for  <tt>var:a</tt>, and <tt>ex:en1</tt>, <tt>ex:en2</tt>, <tt>ex:en3</tt>, for <tt>var:b</tt>. By default, the cartesian product of the values set forms the set of all possibilities to instantiate each statement in the template. We obtain:</p>
<div class="example">
<pre class="highlight">
document
 prefix ex &lt;http://example.org&gt;
 prefix tmpl &lt;http://openprovenance.org/tmpl#&gt;
 prefix xsd &lt;http://www.w3.org/2001/XMLSchema&gt;
 bundle ex:b 
  agent(ex:ag1,[tmpl:order = "[0]" %% xsd:string])
  agent(ex:ag2,[tmpl:order = "[1]" %% xsd:string])
  entity(ex:en1,[tmpl:order = "[0]" %% xsd:string])
  entity(ex:en2,[tmpl:order = "[1]" %% xsd:string])
  entity(ex:en3,[tmpl:order = "[2]" %% xsd:string])
  wasAttributedTo(ex:en1, ex:ag1,[tmpl:order = "[0, 0]" %% xsd:string])
  wasAttributedTo(ex:en1, ex:ag2,[tmpl:order = "[1, 0]" %% xsd:string])
  wasAttributedTo(ex:en2, ex:ag1,[tmpl:order = "[0, 1]" %% xsd:string])
  wasAttributedTo(ex:en2, ex:ag2,[tmpl:order = "[1, 1]" %% xsd:string])
  wasAttributedTo(ex:en3, ex:ag1,[tmpl:order = "[0, 2]" %% xsd:string])
  wasAttributedTo(ex:en3, ex:ag2,[tmpl:order = "[1, 2]" %% xsd:string])
  endBundle
endDocument
<pre>
</div>
In the expanded document, the attribute <tt>tmpl:order</tt> indicates which combination of variable values is used to instantiate the current statement.  In the <tt>wasAttributedTo</tt> statement, it indicates that two independent groups of variables are considered.  There are two possible values (denoted by index 0 and 1) for the first group (i.e., variable <tt>var:b</tt>) and three possible values (denoted by index 0, 1, and 2) for the second group (i.e., variable <tt>var:a</tt>).
</div>


<div class="anexample"  id="example-3">
<p>In some cases, the cartesian product of possibilities is not desirable. For instance, one may want the following values: <tt>ex:ag1</tt>, <tt>ex:ag2</tt> for  <tt>var:a</tt>, and <tt>ex:en1</tt>, <tt>ex:en2</tt> for <tt>var:b</tt>. By default, the cartesian product of the values set forms the set of all possibilities to instantiate each statement in the template. Hence, we modify the template of <a href="#example-1" class="anexample-ref"><span>Example REF</span></a> by adding the <tt>tmpl:linked</tt> attribute in the template.</p>
<div class="example">
<pre class="highlight">
document
 prefix ex &lt;http://example.org&gt;
 prefix var &lt;http://openprovenance.org/var#&gt;

 bundle ex:b 
  agent(var:a)
  entity(var:b)
  wasAttributedTo(var:b, var:a)
 endBundle
endDocument
<pre>
</div>
The expansion now looks like the following. We see that the value <tt>ex:en1</tt> is used  at the same time as <tt>ex:ag1</tt>.
<div class="example">
<pre class="highlight">
document
 prefix ex &lt;http://example.org&gt;
 prefix tmpl &lt;http://openprovenance.org/tmpl#&gt;
 prefix xsd &lt;http://www.w3.org/2001/XMLSchema&gt;
 bundle ex:b 
  agent(ex:ag1,[tmpl:order = "[0]" %% xsd:string])
  agent(ex:ag2,[tmpl:order = "[1]" %% xsd:string])
  entity(ex:en1,[tmpl:order = "[0]" %% xsd:string])
  entity(ex:en2,[tmpl:order = "[1]" %% xsd:string])
  wasAttributedTo(ex:en1, ex:ag1,[tmpl:order = "[0]" %% xsd:string])
  wasAttributedTo(ex:en2, ex:ag2,[tmpl:order = "[1]" %% xsd:string])
 endBundle
endDocument
<pre>
</div>
In the expanded document, the attribute <tt>tmpl:order</tt> indicates that a single group of variables is used for the <tt>wasAttributedTo</tt> statement:  it has two possible values (denoted by index 0 and 1).
</div>

<p>An <dfn>attribute variable</dfn> is a variable that occurs in an attribute-value pair, either in attribute position or in value position.</p>

<p>A <dfn>non-attribute variable</dfn> is a variable that is not an <a>attribute variable</a>.</p>



<div class="anexample"  id="example-4">
<p>A template may contain an <a>attribute variable</a>. For instance, <tt>var:c</tt> is an attribute variable occurring in value position, in the attribute-value pair <tt>prov:type='var:c'</tt>.</p>

<div class="example">
<pre class="highlight">
document
 prefix ex &lt;http://example.org&gt;
 prefix var &lt;http://openprovenance.org/var#&gt;

 bundle ex:b 
  agent(var:a)
  entity(var:b)
  wasAttributedTo(var:b, var:a,[prov:type='var:c'])
 endBundle
endDocument
<pre>
</div>

<p>The variables occurring in non-attribute position determines the number of instantiations according to the cartesian product. So, 
following <a href="#example-1" class="anexample-ref"><span>Example REF</span></a>, we consider values 
<tt>ex:ag1</tt>, <tt>ex:ag2</tt> for <tt>var:a</tt>,
and <tt>ex:en1</tt>, <tt>ex:en2</tt>, <tt>ex:en3</tt>,
for <tt>var:b</tt>.  This leads to six different possibilities.  It is
expect that <tt>var:c</tt> is bound to six different values, one for
each combination of values for <tt>var:a</tt> and <tt>var:b</tt>.
However, attributes can be repeated in a statement, so <tt>var:c</tt> should be bound to six groups of values.
For instance, for the following groups of values
[[<tt>ex:t1</tt>],
 [<tt>ex:t2a</tt>,  <tt>ex:t2b</tt>],
 [<tt>ex:t3</tt>],
 [<tt>ex:t4</tt>],
 [<tt>ex:t5a</tt>, <tt>ex:t5b</tt>, <tt>ex:t5c</tt>],
 [<tt>ex:t6</tt>]], we obtain the following expansion.</p>
<div class="example">
<pre class="highlight">
document
 prefix ex &lt;http://example.org&gt;
 prefix tmpl &lt;http://openprovenance.org/tmpl#&gt;
 prefix xsd &lt;http://www.w3.org/2001/XMLSchema&gt;
 bundle ex:b 
  agent(ex:ag1,[tmpl:order = "[0]" %% xsd:string])
  agent(ex:ag2,[tmpl:order = "[1]" %% xsd:string])
  entity(ex:en1,[tmpl:order = "[0]" %% xsd:string])
  entity(ex:en2,[tmpl:order = "[1]" %% xsd:string])
  entity(ex:en3,[tmpl:order = "[2]" %% xsd:string])
  wasAttributedTo(ex:en1, ex:ag1,[prov:type = 'ex:t1', tmpl:order = "[0, 0]" %% xsd:string])
  wasAttributedTo(ex:en1, ex:ag2,[prov:type = 'ex:t2a', prov:type = 'ex:t2b', tmpl:order = "[1, 0]" %% xsd:string])
  wasAttributedTo(ex:en2, ex:ag1,[prov:type = 'ex:t3', tmpl:order = "[0, 1]" %% xsd:string])
  wasAttributedTo(ex:en2, ex:ag2,[prov:type = 'ex:t4', tmpl:order = "[1, 1]" %% xsd:string])
  wasAttributedTo(ex:en3, ex:ag1,[prov:type = 'ex:t5a', prov:type = 'ex:t5b', prov:type = 'ex:t5c', tmpl:order = "[0, 2]" %% xsd:string])
  wasAttributedTo(ex:en3, ex:ag2,[prov:type = 'ex:t6', tmpl:order = "[1, 2]" %% xsd:string])
 endBundle
endDocument
<pre>
</div>
</div>


</section>

<section id="algorithm">
      <h2>Algorithm</h2>


<section id="grouping">
      <h2>Variable Grouping</h2>


<p>We define a <em>variable group</em>, or <dfn>group</dfn> for short, a set of <a>non-attribute variables</a> that are expected to change values in lockstep with each other. Groups are identified by a natural number. A <dfn>pattern's grouping of non-attribute variables</dfn> is a partitioning of the set of variables occurring in a pattern; each partition forms a group and is allocated a natural number.  </p>

<p>A <dfn>binding</dfn> is an association between a variable and some values. If there is a binding for a variable, it is said to be <dfn>bound</dfn>.</p>

<p>All variables belonging to a given group MUST be bound to the same number of values, since their values have to change in lockstep manner. If this condition is not satisfied, it is an error situation (see error
<a href="#IncorrectNumberOfBindingsForGroupVariable">IncorrectNumberOfBindingsForGroupVariable</a>).</p>

<p>A variable SHALL NOT belong to more than one group.</p>

<p>The algorithm to deterministically create a  grouping of variables for a pattern P is as follows.</p>
<pre class="highlight">
Grouping function (Pattern: P) {
  List&lt;Variable&gt; variable_list=sort(extract_variables(P));

  Hashtable &lt;Variable,Set&lt;Variable&gt;&gt; linked = extract_linked_variables(P); // includes transitive closure
  
  Grouping g=new Grouping();
  int count=0;
  for (Variable v: variable_list) {
    if (!(belong v g)) {
       add v and linked.get(v) to g as group identified by count;
    }
    count++;
  }	
  return g;
}
</pre>

<p>First, all <a>non-attribute variables</a> are extracted from the pattern and sorted (by alphabetical order of their uris).  Then, all linked variables are computed, in the form of a hashmap, associating a variable to the variables it is linked with. It is assumed that the transitive closure of this relation is computed here.  Then, each variable (if not already inserted in the grouping) is added to the grouping with the variables it is linked with. Groups are deterministically identified, starting with value 0.</p>

<p>In the absence of <tt>tmpl:linked</tt> attribute, we have as many groups as variables. </p>

<div class="anexample"  id="example-5">

<p>In <a href="#example-1" class="anexample-ref"><span>Example REF</span></a> and <a href="#example-2" class="anexample-ref"><span>Example REF</span></a>,  the grouping is as follows:</p>

<table class="thinborder" >
<tbody>
<tr><td><b>groups</b></td><td><b>variables</b></td></tr>
<tr><td>0</td><td><tt>var:a</tt></td></tr>
<tr><td>1</td><td><tt>var:b</tt></td></tr>
</tbody>
</table>


<p>In <a href="#example-3" class="anexample-ref"><span>Example REF</span></a>,  the grouping consists of a single group:</p>

<table class="thinborder">
<tbody>
<tr><td><b>groups</b></td><td><b>variables</b></td></tr>
<tr><td>0</td><td><tt>var:a</tt>, <tt>var:b</tt></td></tr>
</tbody>
</table>
</div>
</section>

<section id="group-usage">
      <h2>Group Usage</h2>

<p>A PROV statement MAY contain a set of <a>non-attribute variables</a>. A statement's <dfn>group usage</dfn> is the list of group identifiers corresponding to these variables; the list of group identifiers is ordered in ascending order. The group usage for a statement without variable is the empty list []. A list is noted by integers separated by commas occurring in square brackets. </p>

<div class="anexample"  id="example-6">
<p>In <a href="#example-1" class="anexample-ref"><span>Example REF</span></a>, <a href="#example-2" class="anexample-ref"><span>Example REF</span></a>, and <a href="#example-5" class="anexample-ref"><span>Example REF</span></a>,  the only variable in <tt>agent(var:a)</tt> is <tt>var:a</tt>; since <tt>var:a</tt> belongs to group 0, the current statement's group usage is  [0].</p>

<p>Likewise, the only variable in <tt>entity(var:b)</tt> and <tt>var:b</tt> belongs to group 1; so, the group usage is [1].</p>

<p>Finally, the non-attribute variables in <tt>wasAttributedTo(var:b, var:a)</tt> and
<tt>wasAttributedTo(var:b, var:a, [prov:type='var:c'])</tt>
are <tt>var:a</tt> and <tt>var:b</tt>, with respective groups 0 and 1. So, the group usage is [0,1].</p>

<p>In <a href="#example-3" class="anexample-ref"><span>Example REF</span></a>,  since there is a single group, group usage is [0] for every statement. </p>
</tbody>
</table>
</div>
</section>


<section id="binding">
      <h2>Binding Structure</h2>

<p>Examples have shown that <a>non-attribute variables</a> belonging to a same group evolve in a lockstep manner, whereas the <a>attribute variables</a> should be bound to as many group of values as the statement they occur in as possible instantiations.</p>

<p>Thus, a <a>non-attribute variable<a> is bound to a list of values, and an <a>attribute variable<a> is bound to a list of list of values.</p>

<p>Since all <a>non-attribute variables</a> of a group <em>g</em> in a set of bindings <em><b>B</b></em> MUST be associated with lists of values having the same length; this length is given by <em>number_of_variable_values(<b>B</b>,g)</em>. Otherwise, it is an error, see
<a href="#IncorrectNumberOfBindingsForGroupVariable">IncorrectNumberOfBindingsForGroupVariable</a>.</p>

<p>Section xyz specifies how a set of bindings can be expressed as a PROV document. </p>

<div class="anexample"  id="example-7">
<p>Symbolically, the bindings for <a href="#example-4" class="anexample-ref"><span>Example REF</span></a>, can be expressed as follows:

<table class="thinborder" >
<tbody>
<tr><td><b>variable</b></td><td><b>values</b></td></tr>
<tr><td><tt>var:a</tt></td><td>[<tt>ex:ag1</tt>, <tt>ex:ag2</tt>]</td></tr>
<tr><td><tt>var:b</tt></td><td>[<tt>ex:en1</tt>, <tt>ex:en2</tt>, <tt>ex:en3</tt>]</td></tr>
<tr><td><tt>var:c</tt></td><td>[[<tt>ex:t1</tt>],
 [<tt>ex:t2a</tt>,  <tt>ex:t2b</tt>],
 [<tt>ex:t3</tt>],
 [<tt>ex:t4</tt>],
 [<tt>ex:t5a</tt>, <tt>ex:t5b</tt>, <tt>ex:t5c</tt>],
 [<tt>ex:t6</tt>]]</td></tr>
</tbody>
</table>
</div>
</section>



<section id="indexing">
      <h2>Variable Value Indexing</h2>

<p>Let us consider a set of bindings <em><b>B</b></em> and a statement's <a>group usage</a> [<em>g<sub>1</sub>, ..., g<sub>n</sub></em>], where <em>g<sub>1</sub>, ..., g<sub>n</sub></em> are group identifiers, with <em>n &geq;1</em> (meaning that the statement contains at least one <a>non-attribute variable</a>). A <dfn>variable value index</dfn> is a list [<em>i<sub>1</sub>, ..., i<sub>n</sub></em>] of naturals of length <em>n</em>, such that each <em>0 &leq; i<sub>j</sub> &lt; number_of_variable_values(<b>B</b>, g<sub>j</sub>)</em>.</p>

<p>A <a>variable value index</a> for a <a>group usage</a> and a set of bindings <em><b>B</b></em> denotes a particular combination of variable values. </p>


<div class="anexample"  id="example-8">
<p>Let us consider the bindings   <a href="#example-8" class="anexample-ref"><span>Example REF</span></a>.</p>

<p>The first statement of expansion <a href="#example-4" class="anexample-ref"><span>Example REF</span></a> has index [0] for group usage xyz, denoting ...</p>

<p>The second statement of expansion <a href="#example-4" class="anexample-ref"><span>Example REF</span></a> has index [0] for group usage xyz, denoting ...</p>
</div>

</section>


<section id="expansion">
      <h2>Expansion</h2>
</section>


Basic algorithm:
<ol>
<li> create a mapping of 'group' to list of variables
<ul>
<li> for each variable, put it into a group:
      if specified use that group
      else create a new group (name used needs to be deterministic)
</ul>
</li>

<li> for each statement:
<ol>
<li> from the variables in that statement determine which groups it involves</li>
<li> use the list of involved groups and number of bindings in each to
    generate a multi-dimensional index</li>
<li> for each point in the index, write out the statement using the
   appropiate
    values in the variable bindings; tmpl:order is the point index</li>
</ol>
</li>
</ol>



<table class="thinborder" style="margin-left: auto; margin-right: auto;">
<caption id="variable-table"><span>Table xx</span> Kinds of parameters and variables supported by the templating system</caption>
<tbody>
<tr><td><b>expanded instance parameter</b></td><td><b>definition</b></td></tr>
<tr><td><tt>tmpl:order</tt></td><td>an attribute added to a statement by the expansion process; <br>its value is the index used to compute the actual binding that defined the current instantiation.</td></tr>
</tbody>
</table>


</section>



<section id="environment">
      <h2>Environment</h2>


<table class="thinborder" style="margin-left: auto; margin-right: auto;">
<caption id="variable-table"><span>Table xx</span> Kinds of parameters and variables supported by the templating system</caption>
<tbody>
<tr><td><b>binding parameter</b></td><td><b>definition</b></td></tr>
<tr><td><tt>tmpl:value_0</tt></td><td> an attribute ...</td></tr>
<tr><td><tt>tmpl:value_1</tt></td><td> an attribute ...</td></tr>
<tr><td><tt>tmpl:value_</tt><em>n</em></td><td> an attribute ...</td></tr>
<tr><td><tt>tmpl:2dvalue_0_0</tt></td><td> an attribute ...</td></tr>
<tr><td><tt>tmpl:2dvalue_<em>x</em>_<em>y</em></tt></td><td> an attribute ...</td></tr>
</tbody>
</table>



<div class="example">
<pre>
document
prefix app <http://a/>
prefix var <http://v/>
prefix ex <http://ex/>

entity(var:a,[app:value0='ex:foo',app:value1='ex:bar'])

entity(var:b,[prov:value='ex:foo', tmpl:order=0])
entity(var:b,[prov:value='ex:bar', tmpl:order=1])

endDocument
</pre>
</div>
</section>






<section id="errors">
<h2>Errors</h2>
<p id="UnboundMandatoryVariable">UnboundMandatoryVariable</p>

<p id="IncorrectNumberOfBindingsForGroupVariable">IncorrectNumberOfBindingsForGroupVariable</p>
</section>

<section id="implementation" class="informative">
      <h2>Implementation</h2>


<p>ProvToolbox provconvert command line ... </p>

</section>



</body>
</html>
