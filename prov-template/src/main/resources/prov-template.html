<!DOCTYPE html>
<html>
  <head>
    <title>PROV-TEMPLATE: A Template System for PROV Documents</title>
    <meta charset='utf-8'>
    <script src='http://www.w3.org/Tools/respec/respec-w3c-common'
            async class='remove'></script>
    <script class='remove'>
      var respecConfig = {
          specStatus: "unofficial",
          shortName:  "prov-template",
          editors: [
                {   name:       "Danius Michaelides",
                    url:        "http://www.ecs.soton.ac.uk/~dtm/",
                    company:    "University of Southampton",
                    companyURL: "http://www.ecs.soton.ac.uk/" },
                {   name:       "Trung Dong Huynh",
                    url:        "http://www.ecs.soton.ac.uk/~tdf/",
                    company:    "University of Southampton",
                    companyURL: "http://www.ecs.soton.ac.uk/" },
                {   name:       "Luc Moreau",
                    url:        "http://www.ecs.soton.ac.uk/~lavm/",
                    company:    "University of Southampton",
                    companyURL: "http://www.ecs.soton.ac.uk/" }
          ],
      localBiblio:  {
      "prov-json": {
      title:    "The PROV-JSON Serialization. A JSON Representation for the PROV Data Model"
      ,   href:     "http://www.w3.org/Submission/2013/SUBM-prov-json-20130424/"
      ,   authors:  [
      "Trung Dong Huynh",
      "Michael O. Jewell",
      "Amir Sezavar Keshavarz",
      "Danius T. Michaelides",
      "Huanjia Yang",
      "Luc Moreau"
      ]
      ,   status:   "Member-SUBM"
      ,   publisher:  "W3C"
      }
      }
          //previousMaturity: "FPWD",
          //previousPublishDate:  "1977-03-15",
          //wg:           "Cryptozoology Working Group",
          //wgURI:        "http://www.w3.org/2017/cryptozoology/",
          //wgPublicList: "public-animals",
          //wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/424242/status",
      };
    </script>

 
<style type="text/css">
.note { font-size:small; margin-left:50px }

.diamond {
    font-weight: normal;
    font-style: normal;
    font-size:100%;
    font-family: sans-serif;
}

table.thinborder {
	border-width: 1px;
	border-spacing: 0px;
	border-style: none;
	border-color: gray;
	border-collapse: collapse;
}

table.thinborder th {
	border-width: 1px;
	padding: 0px;
	border-style: solid;
	border-color: gray;
}

table.thinborder td {
	border-width: 1px;
	padding: 2px;
	border-style: solid;
	border-color: gray;
}
</style>

  </head>
  <body>
    <section id='abstract'>
      <p>
        This document describes a templating system to generate PROV.
      </p>
    </section>

    <section id='sotd'>
      <p>
        This is probably the froodiest document that you will read all year. It has
        been authored using new means of achieving consensus that have been made 
        possible through nanoethanol implants.
      </p>
    </section>

<section id="introduction">
      <h2>Introduction</h2>

<p>
Generating provenance compatible with the PROV
data model [[prov-dm]] remains challenging. Indeed, all serializations of PROV, whether 
RDF [[prov-o]],  XML [[prov-xml]],  text [[prov-n]], or JSON
[[prov-json]] have got their own syntactic quirks, which makes them
difficult to generate directly. Likewise, specialized toolkits such as
ProvToolbox and ProvPy require non trivial programming expertise.
</p>

<p>Thus, recognizing that very often provenance follows patterns that are repeated during
the lifetime of an application, we propose a template system for PROV, with the following characteristics:
<ul>
<li> It follows a declarative approach, according to which a pattern
of provenance graph can be declared, specifying some variables acting as placeholder for values to be specified; the
pattern can be instantiated multiple times by providing bindings for
these variables.
<li> It allows a decoupling of the code that instruments the
application and the provenance generation component, the latter being
handled automatically by means of patterns.
<li> To avoid the proliferation of languages and serializations, patterns and bindings are themselves
expressed as PROV documents, allowing tools to be applied to them, to
analyse, check or validate them.
</ul>
</p>





<section id="namespaces">
      <h2>Namespaces</h2>

<p>The following namespaces and prefixes are used throughout this document.</p>



<table class="thinborder" style="margin-left: auto; margin-right: auto;">
<caption id="namespace-table"><span>Table 1</span> Prefix and namespaces used in this specification</caption>
<tbody>
<tr><td><b>Prefix</b></td>
    <td><b>Namespace IRI</b></td>
    <td><b>Definition</b></td></tr>
<tr><td><tt>tmpl</tt></td>
    <td><tt>http://openprovenance.org/tmpl#</tt></td>
    <td>The prov-template namespace</td></tr>
<tr><td><tt>var</tt></td>
    <td><tt>http://openprovenance.org/var#</tt></td>
    <td>The namespace for template variables</td></tr>
<tr><td><tt>vargen</tt></td>
    <td><tt>http://openprovenance.org/vargen#</tt></td>
    <td>The namespace for template gensym variables</td></tr>
<tr><td><tt>prov</tt></td><td><tt>http://www.w3.org/ns/prov#</tt></td><td>The PROV namespace</td></tr>
<tr><td><tt>xsd</tt></td><td><tt>http://www.w3.org/TR/xmlschema11-2/#</tt></td><td>The XSD namespace</td></tr>
</tbody>
</table>

<p>All other namespace prefixes are used in examples only. In
particular, IRIs starting with <tt>http://example.org</tt> represent
some application-dependent IRI [<cite><a class="bibref"
href="#bib-RFC3987">RFC3987</a></cite>].
</section>

<section id="conventions">
      <h2>Conventions</h2>

<p>In this specification, we use the
term <a href="http://www.w3.org/TR/prov-dm/#term-qualified-name">Qualified
Name</a> in accordance to [[prov-dm]], and use its syntax as specified in [[prov-n]]
(see
production <a href="http://www.w3.org/TR/prov-n/#prod-QUALIFIED_NAME">prod-QUALIFIED_NAME</a>).
In compliance with [[prov-dm]], we note that a qualified name can be
mapped to an IRI by concatenating the IRI associated with the prefix
and the local part. </p>

</section>
</section>

<section id="template-definition">
 <h2>Template Definition</h2>

<p>A PROV-template is a PROV document that:
<ul>
<li> MUST contain a single bundle;
<li> MAY contain variables in the form of qualified names <tt>var:<em>x</em></tt> and <tt>vargen:<em>x</em></tt> in any position where such qualified names are allowed in PROV;
<li> MAY contain attributes in the prov-template namespace (prefix <tt>tmpl</tt>).
</ul>


<p>Table 1 summarizes the syntax and meaning of variables and attributes accepted in a PROV template. Their roles will be discussed in detail in the expansion algorithm.</p>

<table class="thinborder" style="margin-left: auto; margin-right: auto;">
<caption id="variable-table"><span>Table 1</span> Kinds of parameters and variables supported by the templating system</caption>
<tbody>
<tr><td><b>template variable</b></td><td><b>definition</b></td></tr>
<tr><td><tt>var:<em>x</em></tt></td><td>A variable <em>x</em> to be
replaced by its value according to the expansion algorithm. If no
binding is found, the following rules are applied.  If the variable occurs in attribute position, the
attribute is dropped. If in optional position of a statement (see
[[prov-n]], <a href="http://www.w3.org/TR/prov-n/#prov-n-optionals">section
2.4</a>), the variable is dropped. If in mandatory position of a
statement, it is an error situation (see error
<a href="#UnboundMandatoryVariable">UnboundMandatoryVariable</a>). </td></tr>
<tr><td><tt>vargen:<em>x</em></tt></td><td>A variable <em>x</em> to be
replaced by its value according to the expansion algorithm. If no
binding is found, the following rules are applied. If the variable occurs in attribute position, a unique qualified name (uuid)  is 
generated. If in optional position of a statement (see
[[prov-n]], <a href="http://www.w3.org/TR/prov-n/#prov-n-optionals">section
2.4</a>), the variable is dropped. If in mandatory position of a
statement, a unique qualified name (uuid)  is 
generated.</td></tr>
<tr><td><b>template parameter</b></td><td><b>definition</b></td></tr>
<tr><td><tt>tmpl:linked</tt></td><td>An attribute associated with a value that MUST be a qualified name also acting as a template variable <tt>v2</tt> (with either <tt>var</tt> or <tt>vargen</tt> namespace prefix). Its presence in a term with identifier <tt>v1</tt>  indicates that the variable <tt>v2</tt>  changes value synchronously with the value of <tt>v1</tt>.</td></tr>
<tr><td><tt>tmpl:label</tt></td><td>An attribute associated with a value that MUST be a qualified name  <tt>var:v</tt> also acting as a template variable. If bound, variable <tt>var:v</tt> MUST be bound to <a href="http://www.w3.org/TR/xmlschema11-2/#string"><span class="name">xsd:string</span></a> values. The expanded current term will contain  a <tt>prov:label</tt> for each value.</td></tr>
<tr><td><tt>tmpl:time</tt></td><td>An attribute associated with a value that MUST be a qualified name  <tt>var:<em>v</em></tt> also acting as a template variable. This attribute may only occur in a Generation, Usage, Invalidation, Start, or End term. If <tt>var:<em>v</em></tt> is bound, variable <tt>var:<em>v</em></tt> MUST be bound to <a href="http://www.w3.org/TR/xmlschema11-2/#dateTime"><span class="name">xsd:dateTime</span></a> values. The expanded current term will be provided the corresponding time information.</td></tr>
<tr><td><tt>tmpl:startTime</tt></td><td>An attribute associated with a value that MUST be a qualified name  <tt>var:<em>v</em></tt> also acting as a template variable. This attribute may only occur in an Activity term. If <tt>var:<em>v</em></tt> is bound, variable <tt>var:<em>v</em></tt> MUST be bound to <a href="http://www.w3.org/TR/xmlschema11-2/#dateTime"><span class="name">xsd:dateTime</span></a> values. The expanded current activity will be provided the corresponding start time information.</td></tr>
<tr><td><tt>tmpl:endTime</tt></td><td>An attribute associated with a value that MUST be a qualified name  <tt>var:<em>v</em></tt> also acting as a template variable. This attribute may only occur in an Activity term. If <tt>var:<em>v</em></tt> is bound, variable <tt>var:<em>v</em></tt> MUST be bound to <a href="http://www.w3.org/TR/xmlschema11-2/#dateTime"><span class="name">xsd:dateTime</span></a> values. The expanded current activity will be provided the corresponding end time information.</td></tr>
</tbody>
</table>

<div class="anexample">
<p>The following template contains two variables <tt>var:a</tt> and <tt>var:b</tt>.</p>
<div class="example">
<pre>
document
 prefix ex: &lt;http://example.org&gt;
 prefix var: &lt;http://openprovenance.org/var#&gt;
 bundle ex:b 
  agent(var:a)
  entity(var:b)
  wasAttributedTo(var:b, var:a)
 endBundle
endDocument
<pre>
</div>
With the following values, <tt>ex:ag</tt> and <tt>ex:en</tt>, for <tt>var:a</tt> and <tt>var:b</tt>, respectively, the template expands to the following document:
<div class="example">
<pre>
document
 prefix ex: &lt;http://example.org&gt;
 prefix tmpl: &lt;http://openprovenance.org/tmpl#&gt;
 bundle ex:b 
  agent(ex:ag, [tmpl:order=""})
  entity(ex:en, [tmpl:order=""])
  wasAttributedTo(ex:en, ex:ag, [tmpl:order=""})
 endBundle
endDocument
<pre>
</div>
</div>

<div class="anexample">
<p>Multiple values are allowed for each variable, for instance <tt>ex:ag1</tt>, <tt>ex:ag2</tt> for  <tt>var:a</tt>, and <tt>ex:en1</tt>, <tt>ex:en2</tt>, <tt>ex:en3</tt>, for <tt>var:b</tt>. By default, the cartesian product of the values set forms the set of all possibilities to instantiate each statement in the template. We obtain:</p>
<div class="example">
<pre>
document
 prefix ex: &lt;http://example.org&gt;
 prefix tmpl: &lt;http://openprovenance.org/tmpl#&gt;
 bundle ex:b 
  agent(ex:ag1, [tmpl:order=""})
  agent(ex:ag2, [tmpl:order=""})
  entity(ex:en1, [tmpl:order=""])
  entity(ex:en2, [tmpl:order=""])
  entity(ex:en3, [tmpl:order=""])
  wasAttributedTo(ex:en1, ex:ag1, [tmpl:order=""})
  wasAttributedTo(ex:en2, ex:ag1, [tmpl:order=""})
  wasAttributedTo(ex:en3, ex:ag1, [tmpl:order=""})
  wasAttributedTo(ex:en1, ex:ag2, [tmpl:order=""})
  wasAttributedTo(ex:en2, ex:ag2, [tmpl:order=""})
  wasAttributedTo(ex:en3, ex:ag2, [tmpl:order=""})
 endBundle
endDocument
<pre>
</div>
In the expanded document, the attribute <tt>tmpl:order</tt> indicates which combination of variable value is used to instantiate the current statement.
</div>


<div class="anexample">
<p>In some cases, the cartesian product of possibilities is not desirable. Instance, one wants the values are allowed for each variable, for instance <tt>ex:ag1</tt>, <tt>ex:ag2</tt> for  <tt>var:a</tt>, and <tt>ex:en1</tt>, <tt>ex:en2</tt>, <tt>ex:en3</tt>, for <tt>var:b</tt>. By default, the cartesian product of the values set forms the set of all possibilities to instantiate each statement in the template. We obtain:</p>
<div class="example">
<pre>
document
 prefix ex: &lt;http://example.org&gt;
 prefix tmpl: &lt;http://openprovenance.org/tmpl#&gt;
 bundle ex:b 
  agent(ex:ag1, [tmpl:order=""})
  agent(ex:ag2, [tmpl:order=""})
  entity(ex:en1, [tmpl:order=""])
  entity(ex:en2, [tmpl:order=""])
  entity(ex:en3, [tmpl:order=""])
  wasAttributedTo(ex:en1, ex:ag1, [tmpl:order=""})
  wasAttributedTo(ex:en2, ex:ag1, [tmpl:order=""})
  wasAttributedTo(ex:en3, ex:ag1, [tmpl:order=""})
  wasAttributedTo(ex:en1, ex:ag2, [tmpl:order=""})
  wasAttributedTo(ex:en2, ex:ag2, [tmpl:order=""})
  wasAttributedTo(ex:en3, ex:ag2, [tmpl:order=""})
 endBundle
endDocument
<pre>
In the expanded document, the attribute <tt>tmpl:order</tt> indicates which combination of variable value is used to instantiate the current statement.
</div>
</div>


</section>

<section id="algorithm">
      <h2>Algorithm</h2>


<section id="grouping">
      <h2>Variable Grouping</h2>
</section>

<section id="using">
      <h2>Group Using</h2>
</section>


<section id="binding">
      <h2>Binding Structure</h2>
</section>

<section id="indexing">
      <h2>Variable Value Indexing</h2>
</section>


<section id="expansion">
      <h2>Expansion</h2>
</section>


Basic algorithm:
<ol>
<li> create a mapping of 'group' to list of variables
<ul>
<li> for each variable, put it into a group:
      if specified use that group
      else create a new group (name used needs to be deterministic)
</ul>
</li>

<li> for each statement:
<ol>
<li> from the variables in that statement determine which groups it involves</li>
<li> use the list of involved groups and number of bindings in each to
    generate a multi-dimensional index</li>
<li> for each point in the index, write out the statement using the
   appropiate
    values in the variable bindings; tmpl:order is the point index</li>
</ol>
</li>
</ol>

</section>

<section id="examples">
      <h2>Examples</h2>

<pre class="example">
Template:
  entity(var:a)
  entity(var:b)
  wasAttributedTo(var:b, var:a)
Bindings:
  var:a = [uri1, uri2, uri3]
  var:b = [uriA, uriB]

groups = { 1: [var:a], 2: [var:b] }

statement 1:
  variables: var:a
  uses: group 1 (length 3)
  index: [(1),(2),(3)]
  write:
    entity(uri1, [tmpl:order="1"])
    entity(uri2, [tmpl:order="2"])
    entity(uri3, [tmpl:order="3"])

statement 2:
  variables: var:b
  uses: group 2 (length 2)
  index: [(1),(2)]
  write:
    entity(uriA, [tmpl:order="1"])
    entity(uriB, [tmpl:order="2"])

statement 3:
  variables: var:b, var:a
  uses: group 2 (length 2), group 1 (length 3)
  index: [(1,1),(1,2)(1,3),(2,1),(2,2),(2,3)]
  write:
    wasAttributedTo(uriA, uri1, [tmpl:order="1,1"])
    wasAttributedTo(uriA, uri2, [tmpl:order="1,2"])
    wasAttributedTo(uriA, uri3, [tmpl:order="1,3"])
    wasAttributedTo(uriB, uri1, [tmpl:order="2,1"])
    wasAttributedTo(uriB, uri2, [tmpl:order="2,2"])
    wasAttributedTo(uriB, uri3, [tmpl:order="2,3"])
</pre>

<pre class="example">
Template:
  entity(var:a, [app:group='1'])
  entity(var:b, [app:group='1'])
  wasAttributedTo(var:b, var:a)
Bindings:
  var:a = [uri1, uri2]
  var:b = [uriA, uriB]
groups = { 1: [var:a, var:b] }
statement 1:
  variables: var:a
  uses: group 1 (length 2)
  index: [(1),(2)]
  write:
    entity(uri1, [tmpl:order="1"])
    entity(uri2, [tmpl:order="2"])

statement 2:
  variables: var:b
  uses: group 2 (length 2)
  index: [(1),(2)]
  write:
    entity(uriA, [tmpl:order="1"])
    entity(uriB, [tmpl:order="2"])

statement 3:
  variables: var:b, var:a
  uses: group 1 (length 2)
  index: [(1),(2)]
  write:
    wasAttributedTo(uriA, uri1, [tmpl:order="1"])
    wasAttributedTo(uriB, uri2, [tmpl:order="2"])
</pre>

<pre class="example">
Template:
  entity(var:x)
  agent(var:ag)
  wasAttributedTo(var:x, var:ag, [ my:attr='var:a' ])
Bindings:
  var:x = [uri1, uri2, uri2]
  var:ag = [uriA, uriB]
  var:a = [[attr1], [attr2], [attr3], [attr4], [attr5], [attr6a, attr6b]]

Expands to:

  entity(uri1, [tmpl:order="1"])
  entity(uri2, [tmpl:order="2"])
  entity(uri3, [tmpl:order="3"])

  entity(uriA, [tmpl:order="1"])
  entity(uriB, [tmpl:order="2"])

  wasAttributedTo(uri1, uriA, [my:attr='attr1', tmpl:order="1,1"])
  wasAttributedTo(uri1, uriB, [my:attr='attr2', tmpl:order="1,2"])
  wasAttributedTo(uri2, uriA, [my:attr='attr3', tmpl:order="2,1"])
  wasAttributedTo(uri2, uriB, [my:attr='attr4', tmpl:order="2,2"])
  wasAttributedTo(uri3, uriA, [my:attr='attr5', tmpl:order="3,1"])
  wasAttributedTo(uri3, uriB, [my:attr='attr6a', my:attr='attr6b', tmpl:order="3,2"])
</pre>
</section>


<section id="environment">
      <h2>Environment</h2>

<div class="example">
<pre>
document
prefix app <http://a/>
prefix var <http://v/>
prefix ex <http://ex/>

entity(var:a,[app:value0='ex:foo',app:value1='ex:bar'])

entity(var:b,[prov:value='ex:foo', tmpl:order=0])
entity(var:b,[prov:value='ex:bar', tmpl:order=1])

endDocument
</pre>
</div>
</section>



<section id="variables">
      <h2>Variables</h2>


<table class="thinborder" style="margin-left: auto; margin-right: auto;">
<caption id="variable-table"><span>Table xx</span> Kinds of parameters and variables supported by the templating system</caption>
<tbody>
<tr><td><b>expanded instance parameter</b></td><td><b>definition</b></td></tr>
<tr><td><tt>tmpl:order</tt></td><td>an attribute added to a statement by the expansion process to specify the index used to compute the actual binding that defined the current instantiation.</td></tr>
<tr><td><b>binding parameter</b></td><td><b>definition</b></td></tr>
<tr><td><tt>tmpl:value_0</tt></td><td> an attribute ...</td></tr>
<tr><td><tt>tmpl:value_1</tt></td><td> an attribute ...</td></tr>
<tr><td><tt>tmpl:value_</tt><em>n</em></td><td> an attribute ...</td></tr>
<tr><td><tt>tmpl:2dvalue_0_0</tt></td><td> an attribute ...</td></tr>
<tr><td><tt>tmpl:2dvalue_<em>x</em>_<em>y</em></tt></td><td> an attribute ...</td></tr>
</tbody>
</table>

</section>


<section id="errors">
<h2>Errors</h2>
UnboundMandatoryVariable
</section>

<section id="implementation" class="informative">
      <h2>Implementation</h2>


<p>ProvToolbox provconvert command line ... </p>

</section>



</body>
</html>
